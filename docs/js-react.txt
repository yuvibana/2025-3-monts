
### 1. **Core React + JavaScript Problem Solving**

* **Component Lifecycle**: Understand all lifecycle methods for class components and know their equivalents in function components using hooks (e.g., `useEffect`, `useLayoutEffect`).
* **State Management**: Be comfortable with both `useState` and `useReducer`. Know how to handle complex state or useReducer for more advanced scenarios.
* **React Context**: Understand how React Context works for managing global state and the trade-offs compared to Redux.
* **Event Handling**: Prepare for scenarios where you need to manage custom events, event delegation, and optimization (e.g., throttling/debouncing).
* **Rendering Optimization**: Be prepared to discuss and implement memoization techniques using `React.memo()`, `useMemo()`, and `useCallback()` for preventing unnecessary renders.

### 2. **Algorithm & Data Structure Challenges**

These are quite common in coding interviews, especially in rounds where they test your problem-solving skills. Some common types of tasks include:

* **Array Manipulation**: Filter, map, reduce, and sort operations.
* **String Manipulation**: Palindromes, substring matching, anagram checks, etc.
* **Searching and Sorting**: Binary search, merge sort, quicksort, etc.
* **Recursion**: Solving problems like factorial, Fibonacci sequence, etc.
* **Dynamic Programming**: Things like the "Knapsack" problem or "Fibonacci" using memoization.
* **Time and Space Complexity**: Be ready to analyze your code for its time complexity (Big O notation).

**Practice on platforms like:**

* LeetCode
* HackerRank
* CodeSignal

### 3. **Real-World Scenarios (Mini Projects)**

Employers like to see your practical skills. You might be asked to:

* **Build a Simple Application**: A to-do list, weather app, or a small CRUD application.
* **Working with APIs**: Fetching data from a public API (like GitHub API) and displaying it in a list, handling errors, etc.
* **UI/UX Considerations**: Focus on responsive design, clean UI with proper use of CSS Flexbox/Grid, and accessibility (e.g., using semantic HTML).
* **Forms Handling**: Building complex forms with validation, conditional inputs, and dynamic form fields.

### 4. **Advanced Topics**

* **React Router**: Routing with dynamic parameters and nested routes.
* **Code Splitting / Lazy Loading**: Using React’s `React.lazy()` and `Suspense` to optimize load times.
* **Testing**: Be prepared for tasks involving testing with tools like Jest and React Testing Library. This could include writing tests for your components, mocking API calls, and testing different states.
* **Error Boundaries**: Handling runtime errors in React apps with error boundaries.

### 5. **System Design (for Senior roles)**

If you're aiming for more senior roles, you'll likely be asked to design systems. This is where you’ll be expected to:

* Design complex features (e.g., a messaging system, real-time collaboration tools).
* Consider things like data flow, caching strategies, and API design.
* Know about backend concepts (even if you're a frontend dev) like REST vs. GraphQL, WebSockets, etc.

### 6. **Behavioral Questions**

Don’t forget soft skills—especially if you’re applying to a team-based role:

* Explain your reasoning when solving problems.
* Talk about the challenges you faced in previous projects.
* Show how you collaborate with others, handle feedback, and prioritize tasks.

### 7. **Mock Interviews**

Finally, **practice with mock interviews** either with a peer or on platforms like:

* Pramp
* Interviewing.io
* LeetCode discuss for problems and solutions.



// ================ Array Manipulation ================== //
Given an array of integers, return a new array containing only the even numbers.
  const arr = [1, 2, 3, 4, 5, 6]
  const evenArr = arr.filter((num) => num % 2 ==0 )
  console.log(evenArr);
  
Given an array of strings, return a new array that only contains strings that have more than 3 characters.
  const words = ["cat", "elephant", "dog", "tiger", "bat"];
  const output = words.filter((str)=> str.length > 3)
  console.log(output);

Given an array of numbers, return a new array that contains only the numbers that are divisible by 5.
  const arr = [10, 22, 35, 50, 42, 60, 7];
  const output = arr.filter((num)=> num % 5 === 0)
  console.log(output);

You have an array of objects representing users, each with a name, age, and isActive property. Return a new array containing only the users who are over 30 years old and have the isActive property set to true.
  const users = [
    { name: "Alice", age: 25, isActive: true },
    { name: "Bob", age: 35, isActive: false },
    { name: "Charlie", age: 40, isActive: true },
    { name: "David", age: 28, isActive: true },
    { name: "Eve", age: 42, isActive: false }
  ];

  function giveActiveAndOver30(arr){
      const newArr = arr.filter((user)=> user.age > 30 && user.isActive === true)
      return newArr;
  }

  console.log(giveActiveAndOver30(users));

  
  Given an array of integers, return a new array where each element is squared, but only include numbers greater than 10 in the result.

  const arr = [2, 5, 12, 7, 20];

  function squaredValue(arr){
      return arr
      .filter((num)=> num > 10)
      .map(num=> num*num)
  }

  console.log(squaredValue(arr));

  You are given an array of objects representing orders. Each order contains an array of items (which itself is an array of objects), and each item has a price and quantity field. You need to return a new array that contains only the orders where the total value of items exceeds $100.

  The total value of items in an order is calculated as: total=∑(price * quantity)
  
  const orders = [
    {
      orderId: 1,
      items: [
        { name: "Laptop", price: 500, quantity: 1 },
        { name: "Mouse", price: 20, quantity: 2 }
      ]
    },
    {
      orderId: 2,
      items: [
        { name: "Phone", price: 300, quantity: 1 },
        { name: "Charger", price: 15, quantity: 2 }
      ]
    },
    {
      orderId: 3,
      items: [
        { name: "Tablet", price: 100, quantity: 1 },
        { name: "Keyboard", price: 40, quantity: 1 }
      ]
    }
  ];
  
  
  function filterOrdersByValue(orders){
        return orders.filter(order => {
      const totalValue = order.items.reduce((total, item) => total + (item.price * item.quantity), 0);
      return totalValue > 100;
    });
  }
  const result = filterOrdersByValue(orders)
  console.log(result)

You are given an array of objects representing students with their names and scores.
Return a new array containing the names of students who scored above 80, sorted by their scores in descending order.

const arr = [
  { name: "Alice", score: 75 },
  { name: "Bob", score: 82 },
  { name: "Charlie", score: 85 },
  { name: "Charlie 1", score: 100 },
  { name: "David", score: 60 }
]

function sortStudentByScore(arr){
    return arr
    .filter((score)=> score.score > 80)
    .sort((a,b)=> b.score - a.score)
    .map(std=>std.name)
}
console.log(sortStudentByScore(arr));

====================================================================
let x = [
    {key: 'a', value:20},    
    {key: 'b', value:12},    
    {key: 'a', value:30},    
    {key: 'd', value:24},    
    {key: 'd', value:25},    
    {key: 'f', value:24},    
    {key: 'a', value:34},    
];

const grouped = x.reduce((acc,item)=>{
    const { key, value } = item;
   if (!acc[key]) {
         acc[key] = [value];
  } else{
      acc[key].push(value)
  } 
  return acc;
}, {});
console.log(grouped)




